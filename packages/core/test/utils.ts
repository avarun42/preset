import nfs from 'node:fs'
import path from 'node:path'
import { randomUUID } from 'node:crypto'
import fs from 'fs-extra'
import { assert, expect } from 'vitest'
import type { SetRequired } from 'type-fest'
import createDebugger from 'debug'
import { definePreset } from '../src'
import { createPresetContext } from '../src/context'
import type { PresetOptions, LocalPreset, ApplyOptions } from '../src'

export interface DirectoryStructure {
	[path: string]: { type: 'file'; content?: any; json?: any } | { type: 'directory' } | { type: 'none' }
}

export const debug = createDebugger('preset:tests')
export const fixturesDirectory = path.resolve(__dirname, './__fixtures__')
export const cleanupFixtures = async(fixtures: string = fixturesDirectory) => await fs.rm(fixtures, { force: true, recursive: true, maxRetries: 3, retryDelay: 1 })
export const presetFixture = (name: string) => path.resolve(__dirname, './fixtures', name)

/**
 * Creates a test preset.
 */
export const makeTestPreset = async(
	customPresetOptions: SetRequired<Partial<PresetOptions>, 'handler'>,
	customApplyOptions?: Partial<ApplyOptions>,
	customLocalPreset?: Partial<LocalPreset>,
) => {
	const preset = definePreset({
		name: 'test-preset',
		flags: {
			test: true,
		},
		...customPresetOptions,
	})

	const context = await createPresetContext(preset, {
		resolvable: '',
		args: [],
		targetDirectory: '',
		...customApplyOptions,
	}, {
		presetFile: '',
		rootDirectory: '',
		...customLocalPreset,
	})

	return { preset, context, executePreset: async() => preset.apply(context) }
}

/**
 * Expect the given directory to match the given structure.
 */
export async function expectStructureMatches(directory: string, ds: DirectoryStructure) {
	debug(`Asserting structure in ${directory}.`)

	for (const [relativePathToEntry, entry] of Object.entries(ds)) {
		const pathToEntry = path.resolve(directory, relativePathToEntry)

		if (entry.type === 'none') {
			assert.isFalse(fs.pathExistsSync(pathToEntry), `${pathToEntry} actually exists although it should not.`)
		}

		if (entry.type === 'file') {
			assert.isTrue(nfs.statSync(pathToEntry, { throwIfNoEntry: false })?.isFile(), `${pathToEntry} is not a file or does not exist`)

			if (entry.content) {
				expect(fs.readFileSync(pathToEntry, { encoding: 'utf-8' })).toBe(entry.content)
			}

			if (entry.json) {
				expect(fs.readJsonSync(pathToEntry)).toMatchObject(entry.json)
			}
		}

		if (entry.type === 'directory') {
			assert.isTrue(nfs.statSync(pathToEntry, { throwIfNoEntry: false })?.isDirectory(), `${pathToEntry} is not a directory or does not exist`)
		}
	}
}

/**
 * Generates the given directory structure.
 */
export async function generateStructure(directory: string, ds?: DirectoryStructure) {
	if (!ds) {
		return
	}

	debug(`Generating structure in ${directory}.`)

	for (const [relativePathToEntry, entry] of Object.entries(ds)) {
		const pathToEntry = path.resolve(directory, relativePathToEntry)

		if (entry.type === 'file') {
			debug(`Writing file to ${pathToEntry}.`)
			await fs.ensureFile(pathToEntry)
			await fs.writeFile(pathToEntry, entry.content ?? '// Generated by preset')
		}

		if (entry.type === 'directory') {
			debug(`Making directory to ${pathToEntry}.`)
			await fs.ensureDir(pathToEntry)
		}
	}
}

interface SandboxOptions {
	fn: (d: { sandboxDirectory: string; targetDirectory: string; rootDirectory: string }, proxyMakeTestPreset: typeof makeTestPreset) => Promise<void>
	rootStructure?: DirectoryStructure
	targetStructure?: DirectoryStructure
	cleanup?: boolean
}

/**
 * Creates a testing directory and a preset inside it.
 */
export async function usingSandbox({ fn, rootStructure, targetStructure, cleanup }: SandboxOptions) {
	const sandboxDirectory = path.resolve(fixturesDirectory, randomUUID())
	const targetDirectory = path.resolve(sandboxDirectory, 'preset-target')
	const rootDirectory = path.resolve(sandboxDirectory, 'preset-root')
	const proxyMakeTestPreset: typeof makeTestPreset = (presetOptions, applyOptions, fs) => makeTestPreset(
		presetOptions,
		{ targetDirectory, ...applyOptions },
		{ rootDirectory, ...fs },
	)

	try {
		debug(`Making sandbox in ${sandboxDirectory}.`)
		await fs.ensureDir(targetDirectory)
		await fs.ensureDir(rootDirectory)
		await generateStructure(rootDirectory, rootStructure)
		await generateStructure(targetDirectory, targetStructure)

		debug('Running sandbox handler.')
		await fn({ sandboxDirectory, targetDirectory, rootDirectory }, proxyMakeTestPreset)
	} finally {
		if (cleanup !== false) {
			await cleanupFixtures(sandboxDirectory)
		}
	}
}
