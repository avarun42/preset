import path from 'node:path'
import { randomUUID } from 'node:crypto'
import fs from 'fs-extra'
import nfs from 'node:fs'
import { expect } from 'vitest'
import type { SetRequired } from 'type-fest'
import createDebugger from 'debug'
import { definePreset } from '../src'
import { createPresetContext } from '../src/context'
import type { PresetOptions, LocalPreset, ApplyOptions } from '../src'

export interface DirectoryStructure {
	[path: string]: { type: 'file'; content?: any } | { type: 'directory' }
}

export const debug = createDebugger('preset:tests')
export const fixturesDirectory = path.resolve(__dirname, '../__fixtures__')
export const cleanupFixtures = () => fs.rm(fixturesDirectory, { force: true, recursive: true, maxRetries: 3, retryDelay: 1 })

/**
 * Creates a test preset.
 */
export const makeTestPreset = async(
	customPresetOptions: SetRequired<Partial<PresetOptions>, 'handler'>,
	customApplyOptions?: Partial<ApplyOptions>,
	customLocalPreset?: Partial<LocalPreset>,
) => {
	const preset = definePreset({
		name: 'test-preset',
		flags: {
			test: true,
		},
		...customPresetOptions,
	})

	const context = await createPresetContext(preset, {
		resolvable: '',
		args: [],
		targetDirectory: '',
		...customApplyOptions,
	}, {
		presetFile: '',
		rootDirectory: '',
		...customLocalPreset,
	})

	return { preset, context, executePreset: async() => preset.apply(context) }
}

/**
 * Expect the given directory to match the given structure.
 */
export function expectStructureMatches(directory: string, ds: DirectoryStructure) {
	debug(`Asserting structure in ${directory}.`)

	for (const [relativePathToEntry, entry] of Object.entries(ds)) {
		const pathToEntry = path.resolve(directory, relativePathToEntry)

		if (entry.type === 'file') {
			expect(nfs.statSync(pathToEntry, { throwIfNoEntry: false })?.isFile()).toBe(true)
		}

		if (entry.type === 'directory') {
			expect(nfs.statSync(pathToEntry, { throwIfNoEntry: false })?.isDirectory()).toBe(true)
		}
	}
}

/**
 * Generates the given directory structure.
 */
export async function generateStructure(directory: string, ds?: DirectoryStructure) {
	if (!ds) {
		return
	}

	debug(`Generating structure in ${directory}.`)

	for (const [relativePathToEntry, entry] of Object.entries(ds)) {
		const pathToEntry = path.resolve(directory, relativePathToEntry)

		if (entry.type === 'file') {
			debug(`Writing file to ${pathToEntry}.`)
			await fs.ensureDir(path.dirname(pathToEntry))
			await fs.writeFile(pathToEntry, entry.content ?? '// Generated by preset')
		}

		if (entry.type === 'directory') {
			debug(`Making directory to ${pathToEntry}.`)
			await fs.ensureDir(pathToEntry)
		}
	}
}

/**
 * Creates a testing directory and a preset inside it.
 */
export async function usingSandbox(
	fn: (d: { sandboxDirectory: string; targetDirectory: string; rootDirectory: string }, proxyMakeTestPreset: typeof makeTestPreset) => Promise<void>,
	ds?: DirectoryStructure,
) {
	const sandboxDirectory = path.resolve(fixturesDirectory, randomUUID())
	const targetDirectory = path.resolve(sandboxDirectory, 'preset-target')
	const rootDirectory = path.resolve(sandboxDirectory, 'preset-root')
	const proxyMakeTestPreset: typeof makeTestPreset = (presetOptions, applyOptions, fs) => makeTestPreset(
		presetOptions,
		{ targetDirectory, ...applyOptions },
		{ rootDirectory, ...fs },
	)

	try {
		debug(`Making sandbox in ${sandboxDirectory}.`)
		await fs.ensureDir(targetDirectory)
		await fs.ensureDir(rootDirectory)
		await generateStructure(rootDirectory, ds)

		debug('Running sandbox handler.')
		await fn({ sandboxDirectory, targetDirectory, rootDirectory }, proxyMakeTestPreset)
	} finally {
		debug(`Cleaning up ${sandboxDirectory}.`)
		await fs.rm(sandboxDirectory, { force: true, recursive: true })
	}
}
